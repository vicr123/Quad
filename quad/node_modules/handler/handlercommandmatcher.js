const db = require("db");
const i18n = require("i18n");
const Geo = require("geo");

let reduceUserListPriorities = [
    (member, value) => member.id === value || member.mention === value,
    (member, value) => `${member.username}#${member.discriminator}` === value,
    (member, value) => `${member.nick}#${member.discriminator}` === value,
    (member, value) => member.username === value,
    (member, value) => member.nick === value,
    (member, value) => `${member.username}#${member.discriminator}`.toLowerCase().includes(value.toLowerCase()),
    (member, value) => `${member.nick}#${member.discriminator}`.toLowerCase().includes(value.toLowerCase()),
];

function reduceUserList(value, oldMember, member) {
    for (let i = 0; i < reduceUserListPriorities.length; i++) {
        if (i < oldMember.priority && reduceUserListPriorities[i](member, value)) {
            return {
                m: member,
                priority: i
            }
        }
    }
    
    return oldMember;
};

class HandlerCommandMatcher {
    #hc;
    #guild;
    #args;
    #flags;
    #sink;
    
    constructor(hc, guild) {
        this.#hc = hc;
        this.#guild = guild;
        this.#args = [];
        this.#flags = {};
        this.#sink = false;
    }
    
    async matchType(value, type) {
        switch (type) {
            case "string": {
                //Function expects a string and we've got a string :)
                return {
                    value: value,
                    success: true
                };
            }
            case "void": {
                //Check for an empty string
                if (value === "") {
                    return {
                        value: true, //Use true so we can use it in an if statement
                        success: true
                    };
                } else {
                    return {
                        success: false
                    };
                }
            }
            case "number": {
                let number = +value;
                if (isNaN(number)) {
                    return {
                        success: false
                    };
                } else {
                    return {
                        value: number,
                        success: true
                    };
                }
            }
            case "integer": {
                let number = parseInt(value);
                if (value !== number.toString()) {
                    return {
                        success: false
                    };
                } else {
                    return {
                        value: number,
                        success: true
                    };
                }
            }
            case "user": {
                if (this.#guild) {
                    //Fetch all members of the guild
                    await this.#guild.fetchAllMembers();

                    let member = this.#guild.members.reduce(reduceUserList.bind(null, value), {
                        m: null,
                        priority: 100
                    });
                    
                    if (member.m !== null) return {
                        value: member.m,
                        success: true
                    }
                }
                break;
            }
            case "globaluser": {
                if (this.#guild) {
                    //Fetch all members of the guild
                    await this.#guild.fetchAllMembers();
                    
                    let member = this.#guild.members.reduce(reduceUserList.bind(null, value), {
                        m: null,
                        priority: 100
                    });
                    
                    if (member.m !== null) return {
                        value: member.m,
                        success: true
                    }
                }
                
                //Use a require() here otherwise the handler is not created in time
                let user = require("handler").bot.users.reduce(reduceUserList.bind(null, value), {
                    m: null,
                    priority: 100
                });
                
                if (user.m !== null) return {
                    value: user.m,
                    success: true
                }

                return {
                    success: false
                }
            }
            case "city": {
                let geo = await Geo.getCoords(value);
                if (geo) {
                    return {
                        value: geo,
                        success: true
                    }
                } else {
                    return {
                        success: false
                    }
                }
            }
        }
        
        //Unknown type
        return {
            success: false
        };
    }
    
    async token(token) {
        //If we're in a sink state, don't bother doing anything
        if (this.#sink) return;
        
        if (token.type === "flag") {
            //Look for a matching flag and set it
            if (this.#flags.hasOwnProperty(token.name)) {
                //Flag already exists
                throw new Error("Flag set twice");
            }
            
            let flagSet = false;
            for (let flag of this.#hc.flags) {
                if (flag.name === token.name) {
                    //Now attempt to match the type of this flag to the string
                    let result = await this.matchType(token.value, flag.type);
                    if (result.success) {
                        this.#flags[flag.name] = result.value;
                        flagSet = true;
                    } else {
                        //Sink the function
                        this.#sink = true;
                        return;
                    }
                }
            }
            
            if (!flagSet) {
                //Flag does not work with this function
                this.#sink = true;
                return;
            }
        } else {
            //Try to parse as the next arg
            let argNumber = this.#args.length;
            
            if (this.#hc.args.length <= argNumber) {
                //Too many args
                this.#sink = true;
                return;
            }
            let arg = this.#hc.args[argNumber];
            
            //Now attempt to match the type of this arg to the string
            let result = await this.matchType(token.value, arg.type);
            if (result.success) {
                this.#args.push(result.value);
            } else {
                //Sink the function
                this.#sink = true;
                return;
            }
        }
    }
    
    async runCommand(prefix, message, mw) {
        let opts = {};
        opts.prefix = prefix;
        
        //Run through middleware
        if (!await mw.run(message, opts, this.#hc.opts, this.#args, this.#flags)) return;
        
        if (this.#hc.opts.translatorRequired) {
            opts.t = (await i18n(message)).t;
        }
        if (this.#hc.opts.dbRequired) {
            opts.db = (await db.get());
        }
        await this.#hc.func(message, opts, this.#args, this.#flags);
        if (this.#hc.opts.dbRequired && !this.#hc.opts.noReleaseDb) {
            opts.db.release();
        }
    }
    
    canRunCommand() {
        //All args need to be satisfied and sink must be false.
        if (this.#sink) return false;
        if (this.#hc.args.length !== this.#args.length) return false;
        
        return true;
    }
    
    havePermission(member) {
        return this.#hc.canRun(member);
    }
}

module.exports = HandlerCommandMatcher;